<?xml version="1.0" encoding="utf-8"?>
<root>
	<!-- 
		Microsoft ResX Schema

		Version 1.3

		The primary goals of this format is to allow a simple XML format 
		that is mostly human readable. The generation and parsing of the 
		various data types are done through the TypeConverter classes 
		associated with the data types.

		Example:

		... ado.net/XML headers & schema ...
		<resheader name="resmimetype">text/microsoft-resx</resheader>
		<resheader name="version">1.3</resheader>
		<resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
		<resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
		<data name="Name1">this is my long string</data>
		<data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
		<data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
			[base64 mime encoded serialized .NET Framework object]
		</data>
		<data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
			[base64 mime encoded string representing a byte array form of the .NET Framework object]
		</data>

		There are any number of "resheader" rows that contain simple 
		name/value pairs.

		Each data row contains a name, and value. The row also contains a 
		type or mimetype. Type corresponds to a .NET class that support 
		text/value conversion through the TypeConverter architecture. 
		Classes that don't support this are serialized and stored with the 
		mimetype set.

		The mimetype is used for serialized objects, and tells the 
		ResXResourceReader how to depersist the object. This is currently not 
		extensible. For a given mimetype the value must be set accordingly:

		Note - application/x-microsoft.net.object.binary.base64 is the format 
		that the ResXResourceWriter will generate, however the reader can 
		read any of the formats listed below.

		mimetype: application/x-microsoft.net.object.binary.base64
		value   : The object must be serialized with 
			: System.Serialization.Formatters.Binary.BinaryFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.soap.base64
		value   : The object must be serialized with 
			: System.Runtime.Serialization.Formatters.Soap.SoapFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.bytearray.base64
		value   : The object must be serialized into a byte array 
			: using a System.ComponentModel.TypeConverter
			: and then encoded with base64 encoding.
	-->
	
	<xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
		<xsd:element name="root" msdata:IsDataSet="true">
			<xsd:complexType>
				<xsd:choice maxOccurs="unbounded">
					<xsd:element name="data">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
								<xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
							<xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
							<xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="resheader">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
	<resheader name="resmimetype">
		<value>text/microsoft-resx</value>
	</resheader>
	<resheader name="version">
		<value>1.3</value>
	</resheader>
	<resheader name="reader">
		<value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	<resheader name="writer">
		<value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	  <data name="BytesEvenCount" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - двоичный код числа содержит четное количество единиц.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 7 23
4 3 15

Результат работы программы:
3</value>
    <comment>Двоичный код числа содержит четное количество единиц.</comment>
  </data>
  <data name="BytesLess3" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - двоичный код числа содержит не более трех единиц.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 7 23
4 3 15

Результат работы программы:
4</value>
    <comment>Двоичный код числа содержит не более трех единиц.</comment>
  </data>
  <data name="EvenCount" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - четное.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 2 3
4 5 6

Результат работы программы:
3</value>
    <comment>Количество четных в матрице</comment>
  </data>
  <data name="EvenCountEvenColumns" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - четный элемент в четном столбце.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 2 3
4 5 6

Результат работы программы:
1</value>
    <comment>Четный элемент в четном столбце.</comment>
  </data>
  <data name="EvenCountEvenRows" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - четный элемент в четной строке.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
4 3
1 2 3
4 5 6
2 2 3
7 6 0

Результат работы программы:
4</value>
    <comment>Четный элемент в четной строке.</comment>
  </data>
  <data name="EvenCountOddColumns" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A, состоящая из элементов a[i, j] размером n x m, состоящая из . Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - четный элемент в нечетном столбце.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 4
1 2 3 7
4 5 6 6
2 2 3 1

Результат работы программы:
3</value>
    <comment>Четный элемент в нечетном столбце.</comment>
  </data>
  <data name="EvenCountOddRows" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A  размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - четный элемент в нечетных строках.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 4
1 2 3 7
4 5 6 6
2 2 3 1

Результат работы программы:
3</value>
    <comment>Четный элемент в нечетных строках.</comment>
  </data>
  <data name="MainDiagonalSum" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A  размером n x n, состоящая из элементов a[i, j]. Где n - количество строк, n - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов в матрице, расположенных на главной диагонали.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
9</value>
    <comment>Сумму элементов в матрице, расположенных на главной диагонали.</comment>
  </data>
  <data name="MinMainDiagonal" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает минимальный элемент матрицы расположенный на главной диагонали.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
1</value>
    <comment>Минимальный элемент матрицы расположенный на главной диагонали.</comment>
  </data>
  <data name="MinSideDiagonal" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает минимальный элемент матрицы расположенный на побочной диагонали.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
2</value>
    <comment>Минимальный элемент матрицы расположенный на побочной диагонали.</comment>
  </data>
  <data name="Mul3Unmul2" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - кратно 3 и некратно 2.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
12 15 3
6 1 5

Результат работы программы:
2</value>
    <comment>Количество элементов в матрице, удовлетворяющих условию a[i, j] - кратно 3 и некратно 2.</comment>
  </data>
  <data name="Mul3Unmul5" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - кратно 3 и некратно 5.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
12 15 3
6 1 5

Результат работы программы:
3</value>
    <comment>Количество элементов в матрице, удовлетворяющих условию a[i, j] - кратно 3 и некратно 5.</comment>
  </data>
  <data name="MulEvenDiagonalNumbers" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает произведение сумм четных элементов a[i, j] матрицы, расположенных на главной и побочной диагоналях.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 7 2
4 4 15
5 7 19

Результат работы программы:
32</value>
    <comment>Произведение сумм четных элементов a[i, j] матрицы, расположенных на главной и побочной диагоналях.</comment>
  </data>
  <data name="MulMainAndSideDiagonal" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает произведение сумм элементов матрицы А, расположенных на главной и побочной диагоналях.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 7 23
4 3 15
5 7 19

Результат работы программы:
713</value>
    <comment>Произведение сумм элементов в матрице, расположенных на главной и побочной диагоналях.</comment>
  </data>
  <data name="MulOddDiagonalNumbers" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает произведение сумм нечетных элементов a[i, j] матрицы А, расположенных на главной и побочной диагоналях.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 7 23
4 2 15
5 7 19

Результат работы программы:
560</value>
    <comment>Произведение сумм нечетных элементов a[i, j] матрицы, расположенных на главной и побочной диагоналях.</comment>
  </data>
  <data name="MulPrimeDiagonalNumbers" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает произведение сумм простых элементов a[i, j] матрицы А, расположенных на главной и побочной диагоналях.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 7 23
4 2 15
6 7 20

Результат работы программы:
50</value>
    <comment>Произведение простых элементов a[i, j] матрицы А, расположенных на главной и побочной диагоналях.</comment>
  </data>
  <data name="MulSumEvenSumOdd" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает произведение суммы элементов матрицы, удовлетворяющих условию a[i, j] - четное, и суммы элементов матрицы, удовлетворяющих условию a[i, j] - нечетное.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
78</value>
    <comment>Произведение сумм четных и нечетных элементов матрицы.</comment>
  </data>
  <data name="NumberRowMinSum" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает номер строки матрицы, с наименьшей суммой элементов.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
0</value>
    <comment>Номер строки матрицы, с наименьшей суммой элементов.</comment>
  </data>
  <data name="OddCount" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A  размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - нечетное.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 2 3
4 5 6

Результат работы программы:
3</value>
    <comment>Количество элементов в матрице, удовлетворяющих условию a[i, j] - нечетное.</comment>
  </data>
  <data name="PrimeNumberCount" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает количество элементов в матрице, удовлетворяющих условию a[i, j] - просто число.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
12 15 3
6 1 5

Результат работы программы:
3</value>
    <comment>Количество элементов в матрице, удовлетворяющих условию a[i, j] - просто число.</comment>
  </data>
  <data name="Scalar" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Элементы в каждой строке обозначают коэффициенты векторов. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает скалярное произведение векторов в матрице.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
82</value>
    <comment>Скалярное произведение векторов в матрице.</comment>
  </data>
  <data name="SideDiagonalSum" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A  размером n x n, состоящая из элементов a[i, j]. Где n - количество строк, n - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов в матрице, расположенных на побочной диагонали.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
10</value>
    <comment>Сумму элементов в матрице, расположенных на побочной диагонали.</comment>
  </data>
  <data name="SumIndexMaxNumber" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму индексов элемента, удовлетворяющему следующему условию a[i, j] - максимальный элемент матрицы. 

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
0</value>
    <comment>Cумма индексов элемента, удовлетворяющему следующему условию a[i, j] - максимальный элемент матрицы.</comment>
  </data>
  <data name="SumIndexMinNumber" xml:space="preserve">
    <value>Во входном потоке задана квадратная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количество столбцов. Каждая строка представляет собой коэффициенты координат вектора. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму индексов элемента, удовлетворяющему следующему условию a[i, j] - минимальный элемент матрицы. 

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
3 3
1 2 3
4 5 6
2 2 3

Результат работы программы:
3</value>
    <comment>Cумму индексов элемента, удовлетворяющему следующему условию a[i, j] - минимальный элемент матрицы.</comment>
  </data>
  <data name="SumMaxInColumn" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов матрицы, удовлетворяющих условию a[i, j] - максимальный элемент в столбце.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
48</value>
    <comment>Сумму элементов матрицы, удовлетворяющих условию a[i, j] - максимальный элемент в столбце.</comment>
  </data>
  <data name="SumMaxInRow" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов матрицы, удовлетворяющих условию a[i, j] - максимальный элемент в строке.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
60</value>
    <comment>Сумму элементов матрицы, удовлетворяющих условию a[i, j] - максимальный элемент в строке.</comment>
  </data>
  <data name="SumMinInColumn" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов матрицы, удовлетворяющих условию a[i, j] - минимальный элемент в столбце.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
31</value>
    <comment>Сумму элементов матрицы, удовлетворяющих условию a[i, j] - минимальный элемент в столбце.</comment>
  </data>
  <data name="SumMinInRow" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов матрицы, удовлетворяющих условию a[i, j] - минимальный элемент в строке.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
5</value>
    <comment>Сумму элементов матрицы, удовлетворяющих условию a[i, j] - минимальный элемент в строке.</comment>
  </data>
  <data name="SumMul4Unmul6" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов в матрице, удовлетворяющих условию a[i, j] - кратно 4, некратно 6.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
8 1 24
6 4 36

Результат работы программы:
12</value>
    <comment>Сумму элементов в матрице, удовлетворяющих условию a[i, j] - кратно 4, некратно 6.</comment>
  </data>
  <data name="SumPrimeNumbers" xml:space="preserve">
    <value>Во входном потоке задана прямоугольная матрица A размером n x m, состоящая из элементов a[i, j]. Где n - количество строк, m - количетсво столбцов. Требуется разработать метод, прототип которого имеет вид:
int F()
Метод возвращает сумму элементов в матрице, удовлетворяющих условию a[i, j] - простое число.

Формат входных данных:
В первой строке записаны n и m разделенные пробелом.
В каждой из последующих n строк записаны m элементов матрицы разделенных пробелом.

Формат выходных данных:
Одно целое число.

Пример.
Входные данные:
2 3
1 7 23
4 3 15

Результат работы программы:
34</value>
    <comment>Сумму элементов в матрице, удовлетворяющих условию a[i, j] - простое число.</comment>
  </data>
</root>